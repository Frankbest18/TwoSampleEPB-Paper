lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3))), col = 1:3, lty = c(1, 2, 2), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3))), col = 1:3, lty = c(1, 2, 2), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
K1 = 7
K2 = 8
curve_G_list = list()
curve_G_main = c()
for (tau_j in tau_grid) {
t_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, grid_1D, mass, tau_j, 0.05)
curve_G_main = c(curve_G_main, t_j)
}
curve_G_list[[1]] = curve_G_main
counter = 2
for (l_i in grid_1D) {
curve_G_sub_i = c()
for (tau_j in tau_grid) {
t_i_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, c(l_i), c(1), tau_j, 0.05)
curve_G_sub_i = c(curve_G_sub_i, t_i_j)
}
curve_G_list[[counter]] = curve_G_sub_i
counter = counter + 1
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3))), col = 1:3, lty = c(1, 2, 2), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
l_edge_list = l_edge(K1, K2)
log(l_edge_list)
K1 = 16
K2 = 8
l_edge_list = l_edge(K1, K2)
log(l_edge_list)
curve_G_list = list()
curve_G_main = c()
for (tau_j in tau_grid) {
t_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, grid_1D, mass, tau_j, 0.05)
curve_G_main = c(curve_G_main, t_j)
}
curve_G_list[[1]] = curve_G_main
counter = 2
for (l_i in grid_1D) {
curve_G_sub_i = c()
for (tau_j in tau_grid) {
t_i_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, c(l_i), c(1), tau_j, 0.05)
curve_G_sub_i = c(curve_G_sub_i, t_i_j)
}
curve_G_list[[counter]] = curve_G_sub_i
counter = counter + 1
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3))), col = 1:3, lty = c(1, 2, 2), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
K1 = 20
K2 = 8
l_edge_list = l_edge(K1, K2)
log(l_edge_list)
curve_G_list = list()
curve_G_main = c()
for (tau_j in tau_grid) {
t_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, grid_1D, mass, tau_j, 0.05)
curve_G_main = c(curve_G_main, t_j)
}
curve_G_list[[1]] = curve_G_main
counter = 2
for (l_i in grid_1D) {
curve_G_sub_i = c()
for (tau_j in tau_grid) {
t_i_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, c(l_i), c(1), tau_j, 0.05)
curve_G_sub_i = c(curve_G_sub_i, t_i_j)
}
curve_G_list[[counter]] = curve_G_sub_i
counter = counter + 1
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3))), col = 1:3, lty = c(1, 2, 2), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
log(grid_1D)
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
K1 = 7
K2 = 8
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
}
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
post_l1_list = c(post_l1_list, post_mass[1])
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda)"), ylim = c(0, 4))
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda)"), ylim = c(0, 1))
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
K1 = 12
K2 = 8
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
post_l1_list = c(post_l1_list, post_mass[1])
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
K1 = 20
K2 = 8
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
post_l1_list = c(post_l1_list, post_mass[1])
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
K1 = 24
K2 = 8
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
post_l1_list = c(post_l1_list, post_mass[1])
}
K1 = 24
K2 = 8
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
post_l1_list = c(post_l1_list, post_mass[1])
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
K1 = 2
K2 = 8
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
post_l1_list = c(post_l1_list, post_mass[1])
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
K1 = 20
K2 = 8
grid_1D = G_list[[5]]
mass = c(0.5, 0.5)
post_l1_list = c()
for (tau_j in tau_grid) {
post_mass = mass_given_tau_j(K1, K2, grid_1D, mass, tau = tau_j)
post_l1_list = c(post_l1_list, post_mass[1])
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = post_l1_list, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = "g(l1)", main = paste("g(l1) wrt hat(lambda) with KA =", K1, ",KB =", K2), ylim = c(0, 1))
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
abline(v = log(grid_1D[1]), lty = 2, lwd = 2, col = 4)
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
lines(x = log(tau_grid), y = post_l1_list, lwd = 2, lty = 5, col = 4)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3)), 'post g(l1)'), col = 1:4, lty = c(1, 2, 2, 5), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
lines(x = log(tau_grid), y = post_l1_list, lwd = 2, lty = 8, col = 4)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3)), 'post g(l1)'), col = 1:4, lty = c(1, 2, 2, 5), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
lines(x = log(tau_grid), y = post_l1_list, lwd = 2, lty = 3, col = 4)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3)), 'post g(l1)'), col = 1:4, lty = c(1, 2, 2, 5), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = paste("curves with K1 =", K1, ',K2 =', K2), ylim = c(0, 4))
lines(x = log(tau_grid), y = curve_G_list[[2]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = curve_G_list[[3]], lwd = 2, lty = 2, col = 3)
lines(x = log(tau_grid), y = post_l1_list, lwd = 2, lty = 3, col = 4)
abline(v = log(grid_1D[1]), lty = 2, col = 'green')
abline(v = log(grid_1D[2]), lty = 2, col = 'purple')
abline(v = log(l_edge(K1, K2)), lty = 2, lwd = 2)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3)), 'post g(l1)'), col = 1:4, lty = c(1, 2, 2, 3), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
source('helper.R')
K1 = 7
K2 = 8
tau_grid = exp(seq(-6, 6, length.out = 100))
# Support of underlying G (point mass)
lambda_list = exp(c(-4, -3,-2, -1, 0, 1, 2, 3, 4))
curve_G_list = list()
counter = 1
for (lambda_i in lambda_list) {
G_i_grid_1D = c(lambda_i)
G_i_mass = c(1)
curve_G_i = c()
for (tau_j in tau_grid) {
t_i_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, G_i_grid_1D, G_i_mass, tau_j, 0.05)
curve_G_i = c(curve_G_i, t_i_j)
}
curve_G_list[[counter]] = curve_G_i
counter = counter + 1
}
par(mar = c(5, 5, 4, 12))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "curves with different underlying G with single point mass", ylim = c(0, 13))
for (i in 2:length(curve_G_list)) {
lines(x = log(tau_grid), y = curve_G_list[[i]], col = i, lty = 1, lwd = 2)
}
legend("topright", legend = paste("log(lambda) = ", log(lambda_list)), col = 1:length(curve_G_list), lty = rep(1, length(curve_G_list)), inset = c(-0.52, 0), xpd = TRUE, lwd = 2)
par(mar = c(5, 5, 4, 12))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "curves with different underlying G with single point mass", ylim = c(1, 13))
for (i in 2:length(curve_G_list)) {
lines(x = log(tau_grid), y = curve_G_list[[i]], col = i, lty = 1, lwd = 2)
}
legend("topright", legend = paste("log(lambda) = ", log(lambda_list)), col = 1:length(curve_G_list), lty = rep(1, length(curve_G_list)), inset = c(-0.52, 0), xpd = TRUE, lwd = 2)
# Support of underlying G (point mass)
lambda_list = exp(c(-4, -3,-2, -1, 0, 0.75, 1, 2, 3, 4))
curve_G_list = list()
counter = 1
for (lambda_i in lambda_list) {
G_i_grid_1D = c(lambda_i)
G_i_mass = c(1)
curve_G_i = c()
for (tau_j in tau_grid) {
t_i_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, G_i_grid_1D, G_i_mass, tau_j, 0.05)
curve_G_i = c(curve_G_i, t_i_j)
}
curve_G_list[[counter]] = curve_G_i
counter = counter + 1
}
par(mar = c(5, 5, 4, 12))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "curves with different underlying G with single point mass", ylim = c(1, 13))
for (i in 2:length(curve_G_list)) {
lines(x = log(tau_grid), y = curve_G_list[[i]], col = i, lty = 1, lwd = 2)
}
legend("topright", legend = paste("log(lambda) = ", log(lambda_list)), col = 1:length(curve_G_list), lty = rep(1, length(curve_G_list)), inset = c(-0.52, 0), xpd = TRUE, lwd = 2)
i = 5
sub_curve_list = list()
for (l_j in G_list[[i]]) {
G_j_grid_1D = c(l_j)
G_j_mass = c(1)
curve_G_j = c()
for (tau_k in tau_grid) {
t_j_k = BF_pvalue_1DNPMLE_solver_positive(K1, K2, G_j_grid_1D, G_j_mass, tau_k, 0.05)
curve_G_j = c(curve_G_j, t_j_k)
}
sub_curve_list[[length(sub_curve_list) + 1]] = curve_G_j
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[i]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "curves with different underlying G with two point masses l1, l2", ylim = c(0, 4))
lines(x = log(tau_grid), y = sub_curve_list[[1]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = sub_curve_list[[2]], lwd = 2, lty = 2, col = 3)
abline(v = log(G_list[[i]][1]), lty = 2, col = 'green')
abline(v = log(G_list[[i]][2]), lty = 2, col = 'purple')
abline(v = log_edge, lty = 2, lwd = 2)
abline(h = 1.96)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3))), col = 1:3, lty = c(1, 2, 2), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
K1 = 7
K2 = 8
log_edge = log(l_edge(K1, K2))
log_edge
tau_grid = exp(seq(-6, 6, length.out = 100))
# Support of underlying G (point mass l1, l2)
l1_list = exp(log_edge + c(-2, -0.5, 0.5, 2))
l2_list = exp(log_edge + c(-2, -0.5, 0.5, 2))
G_list = list()
for (i in 1:length(l1_list)) {
if (i+1 > length(l2_list)) {
next
}
for (j in (i+1):length(l2_list)) {
l1_i = l1_list[i]
l2_j = l2_list[j]
G_i_j_grid_1D = c(l1_i, l2_j)
G_list[[length(G_list) + 1]] = G_i_j_grid_1D
}
}
curve_G_list = list()
counter = 1
for (G_i in G_list) {
G_i_grid_1D = G_i
G_i_mass = c(0.5, 0.5)
curve_G_i = c()
for (tau_j in tau_grid) {
t_i_j = BF_pvalue_1DNPMLE_solver_positive(K1, K2, G_i_grid_1D, G_i_mass, tau_j, 0.05)
curve_G_i = c(curve_G_i, t_i_j)
}
curve_G_list[[counter]] = curve_G_i
counter = counter + 1
}
i = 5
sub_curve_list = list()
for (l_j in G_list[[i]]) {
G_j_grid_1D = c(l_j)
G_j_mass = c(1)
curve_G_j = c()
for (tau_k in tau_grid) {
t_j_k = BF_pvalue_1DNPMLE_solver_positive(K1, K2, G_j_grid_1D, G_j_mass, tau_k, 0.05)
curve_G_j = c(curve_G_j, t_j_k)
}
sub_curve_list[[length(sub_curve_list) + 1]] = curve_G_j
}
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[i]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "curves with different underlying G with two point masses l1, l2", ylim = c(0, 4))
lines(x = log(tau_grid), y = sub_curve_list[[1]], lwd = 2, lty = 2, col = 2)
lines(x = log(tau_grid), y = sub_curve_list[[2]], lwd = 2, lty = 2, col = 3)
abline(v = log(G_list[[i]][1]), lty = 2, col = 'green')
abline(v = log(G_list[[i]][2]), lty = 2, col = 'purple')
abline(v = log_edge, lty = 2, lwd = 2)
abline(h = 1.96)
legend("topright", legend = c(paste("log(l1) = ", round(log(G_list[[i]][1]), 3), "log(l2) = ", round(log(G_list[[i]][2]), 3)), paste('log(l1) = ', round(log(G_list[[i]][1]), 3)), paste('log(l2) = ', round(log(G_list[[i]][2]), 3))), col = 1:3, lty = c(1, 2, 2), inset = c(-0.55, 0), xpd = TRUE, lwd = 2)
plotter_1D = function(df_1D, title) {
plot_1D = ggplot(df_1D, aes(x = log(x), y = 0)) +
geom_segment(aes(xend = log(x), yend = prob), size = 1, color = "blue") +
scale_y_continuous(name = "Density", limits = c(0, max(df_1D$prob))) +
scale_x_continuous(name = expression(log(lambda[i])), limits = c(-6, 6)) +
theme_minimal() +
labs(title = title,
x = expression(log(lambda[i]))) +
theme(plot.title = element_text(hjust = 0.5),
axis.title = element_text(size = 24),
axis.text = element_text(size = 15))
return (plot_1D)
}
K1 = 7
K2 = 8
log_edge = log(l_edge(K1, K2))
log_edge
tau_grid = exp(seq(-6, 6, length.out = 100))
result_csv = read.csv('../Real Dataset Distribution/Real Dataset Distribution Data/Hedenfalk/2D_Hedenfalk.csv')
grid = result_csv[, 2:3]
mass = result_csv[, 4]
grid_1D = grid_2D[, 1] / grid_2D[, 2]
G_Hedenfalk = data.frame(x = grid_1D, prob = mass)
t_1DNPMLE_005 = c()
for (tau in tau_grid) {
t_1DNPMLE_005_i = BF_pvalue_1DNPMLE_solver_positive(K1, K2, grid_1D, mass, tau, 0.05)
t_1DNPMLE_005 = append(t_1DNPMLE_005, t_1DNPMLE_005_i)
}
plot(x = log(tau_grid), y = t_1DNPMLE_005, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "T^BF curves of Hedenfalk", ylim = c(1, 3))
plot(x = log(tau_grid), y = t_1DNPMLE_005, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "T^BF curves of Hedenfalk", ylim = c(1, 3))
abline(h = 1.96)
plotter_1D = function(df_1D, title) {
plot_1D = ggplot(df_1D, aes(x = log(x), y = 0)) +
geom_segment(aes(xend = log(x), yend = prob), size = 1, color = "blue") +
scale_y_continuous(name = "Density", limits = c(0, max(df_1D$prob))) +
scale_x_continuous(name = expression(log(lambda[i])), limits = c(-6, 6)) +
theme_minimal() +
labs(title = title,
x = expression(log(lambda[i]))) +
theme(plot.title = element_text(hjust = 0.5),
axis.title = element_text(size = 24),
axis.text = element_text(size = 15))
return (plot_1D)
}
K1 = 7
K2 = 8
log_edge = log(l_edge(K1, K2))
log_edge
tau_grid = exp(seq(-6, 6, length.out = 100))
result_csv = read.csv('../Real Dataset Distribution/Real Dataset Distribution Data/Hedenfalk/2D_Hedenfalk.csv')
grid = result_csv[, 2:3]
mass = result_csv[, 4]
grid_1D = grid_2D[, 1] / grid_2D[, 2]
G_Hedenfalk = data.frame(x = grid_1D, prob = mass)
t_1DNPMLE_005 = c()
for (tau in tau_grid) {
t_1DNPMLE_005_i = BF_pvalue_1DNPMLE_solver_positive(K1, K2, grid_1D, mass, tau, 0.05)
t_1DNPMLE_005 = append(t_1DNPMLE_005, t_1DNPMLE_005_i)
}
plot(x = log(tau_grid), y = t_1DNPMLE_005, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "T^BF curves of Hedenfalk", ylim = c(1, 3))
abline(h = 1.96)
curve_approx = c()
for (tau_j in tau_grid) {
print(count)
post_mass_j = mass_given_tau_j(K1, K2, grid_1D, mass, tau_j = tau_j)
t_j_approx = 0
for (i in 1:length(grid_1D)) {
l_i = grid_1D[i]
t_i = BF_pvalue_1DNPMLE_solver_positive(K1, K2, c(l_i), c(1), tau_j, 0.05)
t_j_approx = t_j_approx + t_i * post_mass_j[i]
}
curve_approx = c(curve_approx, t_j_approx)
}
plot(x = log(tau_grid), y = t_1DNPMLE_005, type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "T^BF curves of Hedenfalk", ylim = c(1, 3))
lines(x = log(tau_grid), y = curve_approx, lwd = 2, lty = 2, col = 2)
legend('topright', legend = c('Real T^BF curve', 'Approximated T^BF curve'), lty = c(1,2), col = c(1,2), lwd = 2)
r_list = exp(seq(-1, 1.5, length.out = 10))
K1_list = c(3,4,5,9,12,16,21,27,36)
counter = 1
log(l_edge_list)
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "curves with different K1/K2", ylim = c(1, 4))
K2 = 8
r_list = exp(seq(-1, 1.5, length.out = 10))
K2 * r_list
K1_list = c(3,4,5,9,12,16,21,27,36)
curve_G_list = list()
counter = 1
for (K1_i in K1_list) {
curve_G_i = c()
for (tau_j in tau_grid) {
t_i_j = BF_pvalue_1DNPMLE_solver_positive(K1_i, K2, grid_1D, mass, tau_j, 0.05)
curve_G_i = c(curve_G_i, t_i_j)
}
curve_G_list[[counter]] = curve_G_i
counter = counter + 1
}
l_edge_list = l_edge(K1_list, K2)
log(l_edge_list)
par(mar = c(5, 5, 4, 16))
plot(x = log(tau_grid), y = curve_G_list[[1]], type = "l", lwd = 2, col = 1, lty = 1, xlab = expression(log(hat(lambda[i]))), ylab = expression(T[i]^{BF}), main = "curves with different K1/K2", ylim = c(1, 4))
for (i in 2:length(curve_G_list)) {
lines(x = log(tau_grid), y = curve_G_list[[i]], col = i, lty = i, lwd = 2)
}
legend("topright", legend = paste("log(K1/K2) = ", round(log(K1_list/K2), 3)), col = 1:length(curve_G_list), inset = c(-0.40, 0), xpd = TRUE, lwd = 2, lty = 1:length(curve_G_list))
source('EPB.R')
plot_2D = function(u1,u2) {
ggplot(data.frame(u1, u2), aes(u1, u2)) + stat_bin2d(bins = 200)
}
library(GEOquery)
gse = getGEO("GSE17542", GSEMatrix = TRUE)
library(GEOquery)
gse = getGEO("GSE17542", GSEMatrix = TRUE)
library(GEOquery)
gse = getGEO("GSE17542", GSEMatrix = TRUE)
plot_2D = function(u1,u2) {
ggplot(data.frame(u1, u2), aes(u1, u2)) + stat_bin2d(bins = 200)
}
library(Equalden.HD)
data(Hedenfalk)
source('EPB.R')
nrow(Hedenfalk)
head(Hedenfalk)
X1 = Hedenfalk[, 1:7]
X2 = Hedenfalk[, 8:15]
info = information_extractor(X1, X2)
hist(info$S1_list, breaks = 100)
hist(info$S2_list, breaks = 100)
plot_2D(log(info$S1_list), log(info$S2_list))
alpha = 0.1
NPMLE_1D_parameter = c(1000, 0.01, 1.0)
NPMLE_2D_parameter = c(80, 80, 0.01, 1.0)
EVD_NPMLE_1D_parameter = c(80, 0.01, 1.0)
EV_NPMLE_1D_parameter = c(1000, 0.01, 1.0)
algorithm_list = c(1,2,3,4,5,6,7)
alpha = 0.1
NPMLE_1D_parameter = c(1000, 0.01, 1.0)
NPMLE_2D_parameter = c(80, 80, 0.01, 1.0)
EVD_NPMLE_1D_parameter = c(80, 0.01, 1.0)
EV_NPMLE_1D_parameter = c(1000, 0.01, 1.0)
algorithm_list = c(1)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
result = solver(X1, X2, NPMLE_1D_parameter, NPMLE_2D_parameter, EVD_NPMLE_1D_parameter, EV_NPMLE_1D_parameter, alpha, algorithm_list)
